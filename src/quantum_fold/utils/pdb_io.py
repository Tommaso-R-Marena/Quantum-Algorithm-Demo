"""
pdb_io.py
PDB file I/O for real protein structures.

Provides:
  - Download PDB files from RCSB by PDB ID
  - Parse ATOM records to extract Calpha coordinates and sequence
  - Write predicted structures as PDB
  - Handle multi-model and multi-chain files
"""

from __future__ import annotations

import os
import numpy as np
from typing import Dict, List, Optional, Tuple
from pathlib import Path

from ..core.residue import AA_3TO1, AA_1TO3


def fetch_pdb(
    pdb_id: str,
    output_dir: str = ".",
    force: bool = False,
) -> str:
    """
    Download a PDB file from RCSB.
    """
    import urllib.request

    pdb_id = pdb_id.upper().strip()
    filepath = os.path.join(output_dir, f"{pdb_id}.pdb")

    if os.path.exists(filepath) and not force:
        print(f"  PDB file exists: {filepath}")
        return filepath

    url = f"https://files.rcsb.org/download/{pdb_id}.pdb"
    print(f"  Downloading {url}...")

    try:
        urllib.request.urlretrieve(url, filepath)
        print(f"  Saved: {filepath}")
    except Exception as e:
        raise RuntimeError(f"Failed to download PDB {pdb_id}: {e}")

    return filepath


def parse_pdb(
    filepath: str,
    chain: str = "A",
    model: int = 1,
) -> Dict:
    """
    Parse a PDB file and extract Calpha coordinates and sequence.
    """
    ca_coords = []
    sequence = []
    residue_numbers = []
    title = ""
    resolution = None
    current_model = 0
    seen_residues = set()

    with open(filepath, "r") as f:
        for line in f:
            if line.startswith("TITLE"):
                title += line[10:].strip() + " "
            if line.startswith("REMARK   2 RESOLUTION"):
                try:
                    res_str = line[26:].strip().split()[0]
                    resolution = float(res_str)
                except (ValueError, IndexError):
                    pass
            if line.startswith("MODEL"):
                try:
                    current_model = int(line[6:].strip())
                except ValueError:
                    current_model += 1
            if line.startswith("ENDMDL"):
                if current_model >= model:
                    break
            if current_model > 0 and current_model != model:
                continue

            if line.startswith("ATOM") or line.startswith("HETATM"):
                atom_name = line[12:16].strip()
                if atom_name != "CA":
                    continue
                chain_id = line[21].strip()
                if chain_id != chain:
                    continue
                res_name = line[17:20].strip()
                res_num = int(line[22:26].strip())
                alt_loc = line[16].strip()
                if alt_loc and alt_loc != "A":
                    continue
                if res_num in seen_residues:
                    continue
                seen_residues.add(res_num)

                x = float(line[30:38])
                y = float(line[38:46])
                z = float(line[46:54])

                ca_coords.append([x, y, z])
                aa_1 = AA_3TO1.get(res_name, "X")
                sequence.append(aa_1)
                residue_numbers.append(res_num)

    ca_coords = np.array(ca_coords, dtype=np.float64)

    return {
        "ca_coords": ca_coords,
        "sequence": "".join(sequence),
        "residue_numbers": residue_numbers,
        "chain": chain,
        "n_residues": len(ca_coords),
        "resolution": resolution,
        "title": title.strip(),
    }


def write_ca_pdb(
    ca_coords: np.ndarray,
    sequence: str,
    filename: str = "predicted.pdb",
    chain: str = "A",
    remarks: Optional[List[str]] = None,
    b_factors: Optional[np.ndarray] = None,
) -> str:
    """
    Write Calpha coordinates as a PDB file.
    """
    os.makedirs(os.path.dirname(filename) or ".", exist_ok=True)

    with open(filename, "w") as f:
        f.write(f"REMARK   Generated by quantum_fold\n")
        if remarks:
            for r in remarks:
                f.write(f"REMARK   {r}\n")
        f.write(f"REMARK   Sequence: {sequence[:60]}\n")

        for i in range(len(ca_coords)):
            x, y, z = ca_coords[i]
            aa = sequence[i] if i < len(sequence) else "X"
            res_name = AA_1TO3.get(aa, "UNK")
            b = b_factors[i] if b_factors is not None else 0.0

            f.write(
                f"ATOM  {i+1:5d}  CA  {res_name:3s} {chain}{i+1:4d}    "
                f"{x:8.3f}{y:8.3f}{z:8.3f}"
                f"  1.00 {b:6.2f}           C  \n"
            )

        # CONECT
        for i in range(len(ca_coords) - 1):
            f.write(f"CONECT{i+1:5d}{i+2:5d}\n")

        f.write("TER\n")
        f.write("END\n")

    return filename


def write_backbone_pdb(
    backbone: np.ndarray,
    sequence: str,
    cb_coords: Optional[np.ndarray] = None,
    filename: str = "predicted.pdb",
    chain: str = "A",
    remarks: Optional[List[str]] = None,
    confidence: Optional[np.ndarray] = None,
) -> str:
    """
    Write full backbone (N, CA, C) and CB atoms as a PDB file.
    Uses confidence scores (e.g. pLDDT) in the B-factor field.
    """
    os.makedirs(os.path.dirname(filename) or ".", exist_ok=True)
    n_res = len(sequence)

    with open(filename, "w") as f:
        f.write(f"REMARK   Generated by quantum_fold (Backbone + CB)\n")
        if remarks:
            for r in remarks:
                f.write(f"REMARK   {r}\n")

        atom_idx = 1
        for i in range(min(n_res, len(backbone)//3)):
            res_name = AA_1TO3.get(sequence[i], "UNK")
            b = confidence[i] if confidence is not None else 0.0

            # N
            x, y, z = backbone[3 * i]
            f.write(f"ATOM  {atom_idx:5d}  N   {res_name:3s} {chain}{i+1:4d}    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 {b:6.2f}           N  \n")
            atom_idx += 1

            # CA
            x, y, z = backbone[3 * i + 1]
            f.write(f"ATOM  {atom_idx:5d}  CA  {res_name:3s} {chain}{i+1:4d}    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 {b:6.2f}           C  \n")
            atom_idx += 1

            # C
            x, y, z = backbone[3 * i + 2]
            f.write(f"ATOM  {atom_idx:5d}  C   {res_name:3s} {chain}{i+1:4d}    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 {b:6.2f}           C  \n")
            atom_idx += 1

            # CB (if not Glycine and coords available)
            if sequence[i] != "G" and cb_coords is not None and i < len(cb_coords):
                x, y, z = cb_coords[i]
                f.write(f"ATOM  {atom_idx:5d}  CB  {res_name:3s} {chain}{i+1:4d}    "
                        f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 {b:6.2f}           C  \n")
                atom_idx += 1

        f.write("TER\n")
        f.write("END\n")

    return filename
